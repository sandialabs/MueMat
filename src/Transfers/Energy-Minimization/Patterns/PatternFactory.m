    %% PATTERNFACTORY
    % factory class for prolongator/restrictor sparsity patterns

    classdef PatternFactory < TwoLevelFactoryBase
        % factory class for prolongator (and restrictor) sparsity patterns
        %  * abstract factory class with default implementation of Build function
        %  * for a new concrete implementation you've to derive from Pattern
        %    factory and reimplement the virtual BuildPattern function

        properties (Access = protected)
            type_   = [];  % type of pattern (e.g. AP, AffInvAfc)
            filter_ = [];  % contains ThinningStrategy derived object
            UseAfiltered_ = false; % flag for "Afiltered" %% TODO: move me to AP_PatternFactory? not all PatternFactories may support/need an filtered matrix A!
            InitPFact_;    % factory for initial P
        end

        methods
            function [this] = PatternFactory(filterType)
                % PATTERNFACTORY constructor
                %
                %   SYNTAX obj = PatternFactory(filterType)
                %
                %     filterType - (optional) pattern filter (like
                %                  thresholding...), default = []

                % copy constructor
                if nargin == 1 && isa(filterType,class(this)), this.Copy_(filterType,[]); return; end

                if varexist('filterType') this.filter_ = filterType;
                else this.filter_ = []; end;

                % default values
                this.type_ = []; % no pattern type. you cannot use PatternFactory directly! derive from PatternFactory and implement BuildPattern()
            end

            function SetFilter(this, filter)
                % sets pattern filter
                %
                % SYNTAX SetFilter(filter)
                %
                %   filter - filter class (like thresholding)
                this.filter_ = filter;
            end

            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

            function SetPatternType(this,type)
            %SETPATTERNTYPE Set type of sparsity pattern that should be created.
            %
            %   SYNTAX   obj = obj.SetPatternType(type);
            %
            %     type -
            %     obj  -
               this.type_ = type;
            end %SetPatternType()

            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

            function [type] = GetPatternType(this)
              %GETPATTERNTYPE Return type of sparsity pattern that will be created.
              %
              %   SYNTAX   type = obj.GetPatternType();
              %
              type = this.type_;
            end

            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

            function SetInitialPFactory(this, InitPFact)
                % set initial P factory
                %
                % SYNTAX SetInitialPFactory(InitPFact)
                %
                %  InitPFact   - factory that is used for initial P
                this.InitPFact_ = InitPFact;
            end

            function [InitPFact] = GetInitialPFactory(this)
                % get initial P factory
                %
                % SYNTAX InitPFact = GetInitialPFactory()
                %
                %  InitPFact   - factory that is used for initial P
                InitPFact = this.InitPFact_;
            end

            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

            function SetUseAfiltered(this, value)
               this.UseAfiltered_    = value;
            end

            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

            function SetNeeds(this, FineLevel, CoarseLevel)
              % Obtain any cross factory specifications
                %SetNeeds@TwoLevelFactoryBase(this);

                if ~isempty(this.InitPFact_),
                    this.InitPFact_ = FineLevel.InterpretHandle('P',this.InitPFact_);
                    if ~CoarseLevel.IsRequested('P', this.InitPFact_)
                        % if P generated by InitPFact_ is not requested, then
                        % it seems not available, that is we have to build it
                        % here!
                        % prepare for generating initial prolongator
                        this.InitPFact_.SetNeeds(FineLevel,CoarseLevel);
                    end

                    CoarseLevel.Request('P', this.InitPFact_);
                end

                % P-filtering
                if ~isempty(this.filter_),
                    this.filter_.SetNeeds(FineLevel,CoarseLevel);
                end

            end

            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
            function Build(this,FineLevel,CoarseLevel)
                %function [Pattern] = Build(this,FineLevel,CoarseLevel)
                %BUILD Build a pattern based upon smoothed aggregation.
                %      if there's a filter defined, apply filter to sparsity
                %      pattern.
                %
                %   SYNTAX   Pattern = obj.Build(FineLevel,CoarseLevel)
                %
                %     FineLevel        - FineLevel (input)
                %     CoarseLevel      - CoarseLevel (input)
                %     Pattern          - binary sparsity pattern (output)

                %if nargout() ~= 1, error('Build method returns 1 argument'); end
                if isempty(this.type_), error('type_ is empty! did you use a pattern class, that is derived from PatternFactory??'); end

                % pattern already built. reuse it
                if CoarseLevel.IsAvailable('Ppattern', this)
                    Pattern = CoarseLevel.Get('Ppattern', this);

                    % TODO: release variables (for pattern filter)
                    %if ~isempty(this.InitPFact_), CoarseLevel.Release('P', this.InitPFact_); end;
                    return;
                end

                % build pattern
                Pattern = this.BuildPattern(FineLevel,CoarseLevel);

                % apply P-filter (if available)
                if ~isempty(this.filter_)
                    if length(find(Pattern==1)) == nnz(Pattern) % Pattern is binary!
                        warning ('sparsity pattern is binary! filtering may fail\n');
                    end

                    Pattern = this.filter_.Apply(Pattern, FineLevel, CoarseLevel);
                end

                % avoid zero rows
                zerorows = find(full(sum(abs(Pattern)'))==0.0);
                Ptent = CoarseLevel.Get('P',this.InitPFact_);
                Ptent = Ptent.GetMatrixData();
                CoarseLevel.Release('P',this.InitPFact_);
                Pattern(zerorows,:) = abs(Ptent(zerorows,:));

                Pattern = spones(Pattern); % binary output

                % validity check of pattern: check for zero rows in Sparsity pattern
                mxrows = max(Pattern');
                mxzeros = find(mxrows==0.0);
                if(mxzeros > 0)
                    warning('Sparsity pattern has %i zero rows',length(mxzeros));
                end

                CoarseLevel.Set('Ppattern',Pattern,this);
            end
        end

        methods (Abstract = true)
            [Pattern] = BuildPattern(FineLevel, CoarseLevel);
        end

        methods (Access = protected)

            function Copy_(this, src, mc)
                %COPY_
                %
                %   SYNTAX   obj.Copy_(src, mc);
                %
                %     src - Object to copy
                %     mc  - MATLAB Metaclass
                [cmd, data, mc] = this.CopyCmd_(src,mc);
                eval(cmd);
            end
        end % methods
    end
